"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../src/paywall-hooks.ts":
/*!*******************************!*\
  !*** ../src/paywall-hooks.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActionLock: () => (/* binding */ useActionLock),\n/* harmony export */   useBalanceData: () => (/* binding */ useBalanceData),\n/* harmony export */   useConnectorAvailability: () => (/* binding */ useConnectorAvailability),\n/* harmony export */   useConnectorConnect: () => (/* binding */ useConnectorConnect),\n/* harmony export */   usePaymentSubmission: () => (/* binding */ usePaymentSubmission),\n/* harmony export */   usePaywallStatus: () => (/* binding */ usePaywallStatus)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/typedData.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useReadContracts.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useConnect.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/@wagmi/core/dist/esm/errors/config.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useSignTypedData.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useSwitchChain.js\");\n/* harmony import */ var _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./paywall-helpers */ \"(app-pages-browser)/../src/paywall-helpers.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/../src/utils.ts\");\n\n\n\n\n\nfunction useConnectorAvailability(connectors, accountStatus) {\n    const [availability, setAvailability] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useConnectorAvailability.useEffect\": ()=>{\n            let cancelled = false;\n            async function checkConnectorAvailability() {\n                const results = await Promise.all(connectors.map({\n                    \"useConnectorAvailability.useEffect.checkConnectorAvailability\": async (connector)=>{\n                        try {\n                            const authorized = await connector.isAuthorized();\n                            return {\n                                key: connector.uid,\n                                authorized\n                            };\n                        } catch (e) {\n                            return {\n                                key: connector.uid,\n                                authorized: false\n                            };\n                        }\n                    }\n                }[\"useConnectorAvailability.useEffect.checkConnectorAvailability\"]));\n                if (cancelled) return;\n                const next = {};\n                for (const result of results){\n                    next[result.key] = result.authorized;\n                }\n                setAvailability(next);\n            }\n            if (connectors.length > 0) {\n                void checkConnectorAvailability();\n            } else {\n                setAvailability({});\n            }\n            return ({\n                \"useConnectorAvailability.useEffect\": ()=>{\n                    cancelled = true;\n                }\n            })[\"useConnectorAvailability.useEffect\"];\n        }\n    }[\"useConnectorAvailability.useEffect\"], [\n        connectors,\n        accountStatus\n    ]);\n    return availability;\n}\nfunction useBalanceData(params) {\n    const { accepts, chainConfig, chainConfigs, address, showBalances } = params;\n    const balanceConfigs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBalanceData.useMemo[balanceConfigs]\": ()=>(0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceConfigs)(accepts, chainConfig, chainConfigs)\n    }[\"useBalanceData.useMemo[balanceConfigs]\"], [\n        accepts,\n        chainConfig,\n        chainConfigs\n    ]);\n    const balanceContracts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBalanceData.useMemo[balanceContracts]\": ()=>{\n            if (!address) return [];\n            const calls = [];\n            for (const entry of balanceConfigs){\n                if (!entry.config || entry.error || !entry.usdcAddress) continue;\n                calls.push({\n                    address: entry.usdcAddress,\n                    abi: _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.USDC_ABI,\n                    functionName: 'balanceOf',\n                    args: [\n                        address\n                    ],\n                    chainId: entry.config.chainId\n                });\n                calls.push({\n                    address: entry.usdcAddress,\n                    abi: _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.USDC_ABI,\n                    functionName: 'decimals',\n                    chainId: entry.config.chainId\n                });\n            }\n            return calls;\n        }\n    }[\"useBalanceData.useMemo[balanceContracts]\"], [\n        address,\n        balanceConfigs\n    ]);\n    const balanceQueryEnabled = showBalances && Boolean(address) && balanceContracts.length > 0;\n    const balanceQuery = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useReadContracts)({\n        contracts: balanceContracts,\n        allowFailure: true,\n        query: {\n            enabled: balanceQueryEnabled,\n            retry: 2,\n            staleTime: 30000\n        }\n    });\n    const balances = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBalanceData.useMemo[balances]\": ()=>{\n            if (!showBalances || !address || balanceConfigs.length === 0) return [];\n            if (!balanceQuery.data) {\n                return balanceConfigs.filter({\n                    \"useBalanceData.useMemo[balances]\": (entry)=>!entry.config || entry.error\n                }[\"useBalanceData.useMemo[balances]\"]).map({\n                    \"useBalanceData.useMemo[balances]\": (entry)=>{\n                        var _entry_error;\n                        return (0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceError)(entry, (_entry_error = entry.error) !== null && _entry_error !== void 0 ? _entry_error : 'Missing chain configuration');\n                    }\n                }[\"useBalanceData.useMemo[balances]\"]);\n            }\n            const results = [];\n            let dataIndex = 0;\n            for (const entry of balanceConfigs){\n                if (!entry.config || entry.error || !entry.usdcAddress) {\n                    var _entry_error;\n                    results.push((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceError)(entry, (_entry_error = entry.error) !== null && _entry_error !== void 0 ? _entry_error : 'Missing chain configuration'));\n                    continue;\n                }\n                const balanceResult = balanceQuery.data[dataIndex];\n                const decimalsResult = balanceQuery.data[dataIndex + 1];\n                dataIndex += 2;\n                if (!balanceResult || !decimalsResult) {\n                    results.push((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceError)(entry, 'Balance unavailable'));\n                    continue;\n                }\n                if (balanceResult.status === 'failure' || decimalsResult.status === 'failure') {\n                    const err = balanceResult.status === 'failure' ? balanceResult.error : decimalsResult.error;\n                    const message = err instanceof Error ? err.message : 'Failed to fetch balance';\n                    results.push((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceError)(entry, message));\n                    continue;\n                }\n                const decimalsRaw = decimalsResult.result;\n                const balanceRaw = balanceResult.result;\n                if (typeof decimalsRaw !== 'bigint' && typeof decimalsRaw !== 'number' || typeof balanceRaw !== 'bigint' && typeof balanceRaw !== 'number') {\n                    results.push((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildBalanceError)(entry, 'Balance unavailable'));\n                    continue;\n                }\n                const decimalsValue = typeof decimalsRaw === 'bigint' ? Number(decimalsRaw) : decimalsRaw;\n                const balanceValue = typeof balanceRaw === 'bigint' ? balanceRaw : BigInt(balanceRaw);\n                const formatted = Number((0,viem__WEBPACK_IMPORTED_MODULE_4__.formatUnits)(balanceValue, decimalsValue));\n                results.push({\n                    network: entry.accept.network,\n                    chainName: entry.config.name,\n                    balance: formatted,\n                    error: null\n                });\n            }\n            return results;\n        }\n    }[\"useBalanceData.useMemo[balances]\"], [\n        address,\n        balanceConfigs,\n        balanceQuery.data,\n        showBalances\n    ]);\n    return {\n        balances,\n        isLoading: balanceQuery.isFetching\n    };\n}\nfunction paywallReducer(state, action) {\n    switch(action.type){\n        case 'setStatus':\n            return {\n                ...state,\n                status: action.status\n            };\n        case 'setProcessingText':\n            return {\n                ...state,\n                processingText: action.text\n            };\n        case 'setError':\n            return {\n                ...state,\n                status: 'error',\n                errorMessage: action.message\n            };\n        case 'reset':\n            return {\n                status: action.status,\n                errorMessage: '',\n                processingText: action.processingText\n            };\n        default:\n            return state;\n    }\n}\nfunction usePaywallStatus(params) {\n    var _params_defaultProcessingText;\n    const defaultProcessingText = (_params_defaultProcessingText = params === null || params === void 0 ? void 0 : params.defaultProcessingText) !== null && _params_defaultProcessingText !== void 0 ? _params_defaultProcessingText : _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PROCESSING_TEXT;\n    const onError = params === null || params === void 0 ? void 0 : params.onError;\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(paywallReducer, {\n        status: 'connect',\n        errorMessage: '',\n        processingText: defaultProcessingText\n    });\n    const setStatus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaywallStatus.useCallback[setStatus]\": (status)=>{\n            dispatch({\n                type: 'setStatus',\n                status\n            });\n        }\n    }[\"usePaywallStatus.useCallback[setStatus]\"], []);\n    const setProcessingText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaywallStatus.useCallback[setProcessingText]\": (text)=>{\n            dispatch({\n                type: 'setProcessingText',\n                text\n            });\n        }\n    }[\"usePaywallStatus.useCallback[setProcessingText]\"], []);\n    const showError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaywallStatus.useCallback[showError]\": (message, err)=>{\n            const errorText = message || 'Payment failed. Please try again.';\n            dispatch({\n                type: 'setError',\n                message: errorText\n            });\n            if (err instanceof Error) {\n                onError === null || onError === void 0 ? void 0 : onError(err);\n            } else if (message) {\n                onError === null || onError === void 0 ? void 0 : onError(new Error(message));\n            }\n        }\n    }[\"usePaywallStatus.useCallback[showError]\"], [\n        onError\n    ]);\n    const resetState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaywallStatus.useCallback[resetState]\": function() {\n            let status = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'connect';\n            dispatch({\n                type: 'reset',\n                status,\n                processingText: defaultProcessingText\n            });\n        }\n    }[\"usePaywallStatus.useCallback[resetState]\"], [\n        defaultProcessingText\n    ]);\n    return {\n        status: state.status,\n        errorMessage: state.errorMessage,\n        processingText: state.processingText,\n        setStatus,\n        setProcessingText,\n        showError,\n        resetState\n    };\n}\nfunction useActionLock() {\n    const actionLockRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const actionNonceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const [isActionBusy, setIsActionBusy] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const beginAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useActionLock.useCallback[beginAction]\": ()=>{\n            if (actionLockRef.current) return null;\n            actionLockRef.current = true;\n            setIsActionBusy(true);\n            actionNonceRef.current += 1;\n            return actionNonceRef.current;\n        }\n    }[\"useActionLock.useCallback[beginAction]\"], []);\n    const endAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useActionLock.useCallback[endAction]\": ()=>{\n            actionLockRef.current = false;\n            setIsActionBusy(false);\n        }\n    }[\"useActionLock.useCallback[endAction]\"], []);\n    const isActionStale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useActionLock.useCallback[isActionStale]\": (actionId)=>actionNonceRef.current !== actionId\n    }[\"useActionLock.useCallback[isActionStale]\"], []);\n    const resetAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useActionLock.useCallback[resetAction]\": ()=>{\n            actionNonceRef.current += 1;\n            actionLockRef.current = false;\n            setIsActionBusy(false);\n        }\n    }[\"useActionLock.useCallback[resetAction]\"], []);\n    return {\n        beginAction,\n        endAction,\n        isActionStale,\n        resetAction,\n        isActionBusy\n    };\n}\nfunction useConnectorConnect(params) {\n    const { accountStatus, resolvedChain, onConnected, beginAction, endAction, isActionStale, setStatus, setProcessingText, showError } = params;\n    const connect = (0,wagmi__WEBPACK_IMPORTED_MODULE_5__.useConnect)();\n    const isAlreadyConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useConnectorConnect.useCallback[isAlreadyConnected]\": (error)=>{\n            var _err_message;\n            if (!error) return false;\n            if (error instanceof wagmi__WEBPACK_IMPORTED_MODULE_6__.ConnectorAlreadyConnectedError) return true;\n            const err = error;\n            if (err.name === 'ConnectorAlreadyConnectedError') return true;\n            return Boolean((_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.toLowerCase().includes('already connected'));\n        }\n    }[\"useConnectorConnect.useCallback[isAlreadyConnected]\"], []);\n    const connectWithConnector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useConnectorConnect.useCallback[connectWithConnector]\": async (connector)=>{\n            if (!resolvedChain) {\n                showError('Missing chain configuration for this payment.');\n                return;\n            }\n            if (accountStatus === 'connected') {\n                onConnected();\n                return;\n            }\n            const actionId = beginAction();\n            if (!actionId) return;\n            try {\n                setStatus('processing');\n                setProcessingText(\"Connecting \".concat(connector.name, \"...\"));\n                await connect.mutateAsync({\n                    connector,\n                    chainId: resolvedChain.chainId\n                });\n                if (isActionStale(actionId)) return;\n                onConnected();\n            } catch (err) {\n                if (isAlreadyConnected(err)) {\n                    onConnected();\n                } else if ((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.isUserRejection)(err)) {\n                    showError('Connection rejected by user', err);\n                } else {\n                    showError(err.message || 'Failed to connect wallet', err);\n                }\n            } finally{\n                endAction();\n            }\n        }\n    }[\"useConnectorConnect.useCallback[connectWithConnector]\"], [\n        accountStatus,\n        beginAction,\n        connect,\n        endAction,\n        isAlreadyConnected,\n        isActionStale,\n        onConnected,\n        resolvedChain,\n        setProcessingText,\n        setStatus,\n        showError\n    ]);\n    return {\n        connectWithConnector,\n        isPending: connect.isPending\n    };\n}\nfunction usePaymentSubmission(params) {\n    const { accountAddress, accountChainId, requirement, resolvedChain, amountAtomic, paymentRequired, currentUrl, requestInit, onSuccess, beginAction, endAction, isActionStale, setStatus, setProcessingText, showError } = params;\n    const signTypedData = (0,wagmi__WEBPACK_IMPORTED_MODULE_7__.useSignTypedData)();\n    const switchChain = (0,wagmi__WEBPACK_IMPORTED_MODULE_8__.useSwitchChain)();\n    const ensureChain = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaymentSubmission.useCallback[ensureChain]\": async (config)=>{\n            if (accountChainId === config.chainId) return;\n            try {\n                await switchChain.mutateAsync({\n                    chainId: config.chainId\n                });\n            } catch (switchError) {\n                throw new Error(switchError.message || \"Please switch to \".concat(config.name, \" in your wallet.\"));\n            }\n        }\n    }[\"usePaymentSubmission.useCallback[ensureChain]\"], [\n        accountChainId,\n        switchChain\n    ]);\n    const signPayment = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"usePaymentSubmission.useCallback[signPayment]\": async ()=>{\n            if (!accountAddress) {\n                showError('Wallet not connected.');\n                return;\n            }\n            if (!requirement || !resolvedChain) {\n                showError('Missing payment requirement or chain configuration.');\n                return;\n            }\n            if (!requirement.payTo || !amountAtomic || !requirement.asset) {\n                showError('Payment requirement missing required fields.');\n                return;\n            }\n            const extra = requirement.extra;\n            const domainName = typeof (extra === null || extra === void 0 ? void 0 : extra.name) === 'string' ? extra.name : null;\n            const domainVersion = typeof (extra === null || extra === void 0 ? void 0 : extra.version) === 'string' ? extra.version : null;\n            if (!domainName || !domainVersion) {\n                showError('Payment requirement missing EIP-712 domain details.');\n                return;\n            }\n            const actionId = beginAction();\n            if (!actionId) return;\n            try {\n                setStatus('processing');\n                setProcessingText('Checking network...');\n                await ensureChain(resolvedChain);\n                if (isActionStale(actionId)) return;\n                setProcessingText('Preparing payment...');\n                const from = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(accountAddress);\n                const to = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(requirement.payTo);\n                const asset = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(requirement.asset);\n                var _normalizeAtomicAmount;\n                const normalizedAmount = (_normalizeAtomicAmount = (0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.normalizeAtomicAmount)(amountAtomic)) !== null && _normalizeAtomicAmount !== void 0 ? _normalizeAtomicAmount : amountAtomic;\n                const value = BigInt(normalizedAmount);\n                var _requirement_maxTimeoutSeconds;\n                const maxTimeoutSeconds = (_requirement_maxTimeoutSeconds = requirement.maxTimeoutSeconds) !== null && _requirement_maxTimeoutSeconds !== void 0 ? _requirement_maxTimeoutSeconds : _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT_SECONDS;\n                const now = Math.floor(Date.now() / 1000);\n                const validAfter = BigInt(now - _paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.CLOCK_SKEW_SECONDS);\n                const validBefore = BigInt(now + maxTimeoutSeconds);\n                const nonce = (0,viem__WEBPACK_IMPORTED_MODULE_10__.toHex)(crypto.getRandomValues(new Uint8Array(32)));\n                const domain = {\n                    name: domainName,\n                    version: domainVersion,\n                    chainId: resolvedChain.chainId,\n                    verifyingContract: asset\n                };\n                const message = {\n                    from,\n                    to,\n                    value,\n                    validAfter,\n                    validBefore,\n                    nonce\n                };\n                setProcessingText('Please sign in your wallet...');\n                const typedData = (0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.buildTransferAuthorizationTypedData)({\n                    domain,\n                    message\n                });\n                (0,viem__WEBPACK_IMPORTED_MODULE_11__.validateTypedData)(typedData);\n                const signature = await signTypedData.mutateAsync(typedData);\n                if (isActionStale(actionId)) return;\n                setProcessingText('Submitting payment...');\n                const paymentPayload = {\n                    x402Version: paymentRequired.x402Version,\n                    scheme: requirement.scheme,\n                    network: requirement.network,\n                    payload: {\n                        signature,\n                        authorization: {\n                            from,\n                            to,\n                            value: value.toString(),\n                            validAfter: validAfter.toString(),\n                            validBefore: validBefore.toString(),\n                            nonce\n                        }\n                    }\n                };\n                const paymentHeader = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.encodeBase64Json)(paymentPayload);\n                const headers = new Headers(requestInit === null || requestInit === void 0 ? void 0 : requestInit.headers);\n                headers.set('X-PAYMENT-SIGNATURE', paymentHeader);\n                headers.set('PAYMENT-SIGNATURE', paymentHeader);\n                headers.set('Accept', 'application/json');\n                const response = await fetch(currentUrl, {\n                    method: (requestInit === null || requestInit === void 0 ? void 0 : requestInit.method) || 'GET',\n                    ...requestInit,\n                    headers\n                });\n                if (isActionStale(actionId)) return;\n                if (!response.ok) {\n                    const errorData = await response.json().catch({\n                        \"usePaymentSubmission.useCallback[signPayment]\": ()=>({})\n                    }[\"usePaymentSubmission.useCallback[signPayment]\"]);\n                    const message = errorData.message || 'Payment verification failed';\n                    throw new Error(message);\n                }\n                let result;\n                try {\n                    result = await response.json();\n                } catch (e) {\n                    result = await response.text();\n                }\n                if (isActionStale(actionId)) return;\n                setStatus('success');\n                onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(result, {\n                    response,\n                    paymentHeader\n                });\n            } catch (err) {\n                if ((0,_paywall_helpers__WEBPACK_IMPORTED_MODULE_1__.isUserRejection)(err)) {\n                    showError('Transaction rejected by user', err);\n                } else {\n                    showError(err.message || 'Payment failed. Please try again.', err);\n                }\n            } finally{\n                endAction();\n            }\n        }\n    }[\"usePaymentSubmission.useCallback[signPayment]\"], [\n        accountAddress,\n        amountAtomic,\n        beginAction,\n        endAction,\n        ensureChain,\n        isActionStale,\n        onSuccess,\n        paymentRequired.x402Version,\n        requestInit,\n        requirement,\n        resolvedChain,\n        setProcessingText,\n        setStatus,\n        showError,\n        signTypedData,\n        currentUrl\n    ]);\n    return {\n        signPayment,\n        isPending: signTypedData.isPending || switchChain.isPending\n    };\n}\n\n\n;\n    (function() {\n      var _a, _b;\n      if (typeof self < \"u\" && \"$RefreshHelpers$\" in self) {\n        var currentExports = module.exports, prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n          module.hot.dispose(function(data) {\n            data.prevSignature = self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n          });\n          module.hot.accept();\n          if (prevSignature !== null)\n            if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports)))\n              module.hot.invalidate();\n            else\n              self.$RefreshHelpers$.scheduleUpdate();\n        } else {\n          var isNoLongerABoundary = prevSignature !== null;\n          if (isNoLongerABoundary)\n            module.hot.invalidate();\n        }\n      }\n    })();\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zcmMvcGF5d2FsbC1ob29rcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ0M7QUFReEU7QUFrQlk7QUFDZ0I7QUFzQnBDLFNBQVN5Qix5QkFDZEMsVUFBZ0MsRUFDaENDLGFBQXFCO0lBRXJCLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUd4QiwrQ0FBUUEsQ0FBMEIsQ0FBQztJQUUzRUosZ0RBQVNBOzhDQUFDO1lBQ1IsSUFBSTZCLFlBQVk7WUFFaEIsZUFBZUM7Z0JBQ2IsTUFBTUMsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQy9CUixXQUFXUyxHQUFHO3FGQUFDLE9BQU9DO3dCQUNwQixJQUFJOzRCQUNGLE1BQU1DLGFBQWEsTUFBTUQsVUFBVUUsWUFBWTs0QkFDL0MsT0FBTztnQ0FBRUMsS0FBS0gsVUFBVUksR0FBRztnQ0FBRUg7NEJBQVc7d0JBQzFDLEVBQUUsVUFBTTs0QkFDTixPQUFPO2dDQUFFRSxLQUFLSCxVQUFVSSxHQUFHO2dDQUFFSCxZQUFZOzRCQUFNO3dCQUNqRDtvQkFDRjs7Z0JBRUYsSUFBSVAsV0FBVztnQkFDZixNQUFNVyxPQUFnQyxDQUFDO2dCQUN2QyxLQUFLLE1BQU1DLFVBQVVWLFFBQVM7b0JBQzVCUyxJQUFJLENBQUNDLE9BQU9ILEdBQUcsQ0FBQyxHQUFHRyxPQUFPTCxVQUFVO2dCQUN0QztnQkFDQVIsZ0JBQWdCWTtZQUNsQjtZQUVBLElBQUlmLFdBQVdpQixNQUFNLEdBQUcsR0FBRztnQkFDekIsS0FBS1o7WUFDUCxPQUFPO2dCQUNMRixnQkFBZ0IsQ0FBQztZQUNuQjtZQUVBO3NEQUFPO29CQUNMQyxZQUFZO2dCQUNkOztRQUNGOzZDQUFHO1FBQUNKO1FBQVlDO0tBQWM7SUFFOUIsT0FBT0M7QUFDVDtBQUVPLFNBQVNnQixlQUFlQyxNQU05QjtJQUNDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsT0FBTyxF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TSxLQUFJO29CQUMvQixHQUFHNUMsV0FBVztvQkFDZHVDO2dCQUNGO2dCQUNBLElBQUkzRCxjQUFjQyxXQUFXO2dCQUU3QixJQUFJLENBQUM2RCxTQUFTRyxFQUFFLEVBQUU7b0JBQ2hCLE1BQU1DLFlBQVksTUFBTUosU0FBU0ssSUFBSSxHQUFHQyxLQUFLO3lFQUFDLElBQU8sRUFBQzs7b0JBQ3RELE1BQU01RyxVQUNKLFVBQW9DQSxPQUFPLElBQzNDO29CQUNGLE1BQU0sSUFBSUMsTUFBTUQ7Z0JBQ2xCO2dCQUVBLElBQUl0QztnQkFDSixJQUFJO29CQUNGQSxTQUFTLE1BQU00SSxTQUFTSyxJQUFJO2dCQUM5QixFQUFFLFVBQU07b0JBQ05qSixTQUFTLE1BQU00SSxTQUFTakYsSUFBSTtnQkFDOUI7Z0JBQ0EsSUFBSW1CLGNBQWNDLFdBQVc7Z0JBRTdCZCxVQUFVO2dCQUNWa0Msc0JBQUFBLGdDQUFBQSxVQUFZbkcsUUFBUTtvQkFBRTRJO29CQUFVSjtnQkFBYztZQUNoRCxFQUFFLE9BQU9uRyxLQUFjO2dCQUNyQixJQUFJMUQsaUVBQWVBLENBQUMwRCxNQUFNO29CQUN4QjhCLFVBQVUsZ0NBQWdDOUI7Z0JBQzVDLE9BQU87b0JBQ0w4QixVQUFVLElBQWU3QixPQUFPLElBQUkscUNBQXFDRDtnQkFDM0U7WUFDRixTQUFVO2dCQUNSd0M7WUFDRjtRQUNGO3dEQUFHO1FBQ0RlO1FBQ0FHO1FBQ0FwQjtRQUNBRTtRQUNBeUI7UUFDQXhCO1FBQ0FxQjtRQUNBSCxnQkFBZ0JtQyxXQUFXO1FBQzNCakM7UUFDQUo7UUFDQVo7UUFDQWhCO1FBQ0FEO1FBQ0FFO1FBQ0FpQztRQUNBSDtLQUNEO0lBRUQsT0FBTztRQUNMTztRQUNBZCxXQUFXVSxjQUFjVixTQUFTLElBQUlXLFlBQVlYLFNBQVM7SUFDN0Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NpZC9kZXYvcGF5d2FsbC00MDIvc3JjL3BheXdhbGwtaG9va3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVkdWNlciwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZvcm1hdFVuaXRzLCBnZXRBZGRyZXNzLCB0b0hleCwgdmFsaWRhdGVUeXBlZERhdGEsIHR5cGUgQWRkcmVzcyB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHR5cGUgeyBDb25uZWN0b3IgfSBmcm9tICd3YWdtaSc7XG5pbXBvcnQge1xuICBDb25uZWN0b3JBbHJlYWR5Q29ubmVjdGVkRXJyb3IsXG4gIHVzZUNvbm5lY3QsXG4gIHVzZVJlYWRDb250cmFjdHMsXG4gIHVzZVNpZ25UeXBlZERhdGEsXG4gIHVzZVN3aXRjaENoYWluLFxufSBmcm9tICd3YWdtaSc7XG5pbXBvcnQgdHlwZSB7XG4gIEJhbGFuY2VJbmZvLFxuICBDaGFpbkNvbmZpZyxcbiAgWDQwMlBheW1lbnRSZXF1aXJlbWVudCxcbiAgWDQwMlBheW1lbnRSZXF1aXJlZCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBidWlsZEJhbGFuY2VDb25maWdzLFxuICBidWlsZEJhbGFuY2VFcnJvcixcbiAgYnVpbGRUcmFuc2ZlckF1dGhvcml6YXRpb25UeXBlZERhdGEsXG4gIENMT0NLX1NLRVdfU0VDT05EUyxcbiAgREVGQVVMVF9QUk9DRVNTSU5HX1RFWFQsXG4gIERFRkFVTFRfVElNRU9VVF9TRUNPTkRTLFxuICBpc1VzZXJSZWplY3Rpb24sXG4gIG5vcm1hbGl6ZUF0b21pY0Ftb3VudCxcbiAgdHlwZSBCYWxhbmNlQ29uZmlnRW50cnksXG4gIFVTRENfQUJJLFxufSBmcm9tICcuL3BheXdhbGwtaGVscGVycyc7XG5pbXBvcnQgeyBlbmNvZGVCYXNlNjRKc29uIH0gZnJvbSAnLi91dGlscyc7XG5cbnR5cGUgUGF5d2FsbFN0YXR1cyA9ICdjb25uZWN0JyB8ICdjb25uZWN0ZWQnIHwgJ3Byb2Nlc3NpbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2Vycm9yJztcbnR5cGUgUGF5d2FsbFN0YXRlID0ge1xuICBzdGF0dXM6IFBheXdhbGxTdGF0dXM7XG4gIGVycm9yTWVzc2FnZTogc3RyaW5nO1xuICBwcm9jZXNzaW5nVGV4dDogc3RyaW5nO1xufTtcbnR5cGUgUGF5d2FsbEFjdGlvbiA9XG4gIHwgeyB0eXBlOiAnc2V0U3RhdHVzJzsgc3RhdHVzOiBQYXl3YWxsU3RhdHVzIH1cbiAgfCB7IHR5cGU6ICdzZXRQcm9jZXNzaW5nVGV4dCc7IHRleHQ6IHN0cmluZyB9XG4gIHwgeyB0eXBlOiAnc2V0RXJyb3InOyBtZXNzYWdlOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogJ3Jlc2V0Jzsgc3RhdHVzOiBQYXl3YWxsU3RhdHVzOyBwcm9jZXNzaW5nVGV4dDogc3RyaW5nIH07XG5cbnR5cGUgQmFsYW5jZUNvbnRyYWN0c0NhbGwgPSB7XG4gIGFkZHJlc3M6IEFkZHJlc3M7XG4gIGFiaTogdHlwZW9mIFVTRENfQUJJO1xuICBmdW5jdGlvbk5hbWU6ICdiYWxhbmNlT2YnIHwgJ2RlY2ltYWxzJztcbiAgYXJncz86IHJlYWRvbmx5IFtBZGRyZXNzXTtcbiAgY2hhaW5JZDogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbm5lY3RvckF2YWlsYWJpbGl0eShcbiAgY29ubmVjdG9yczogcmVhZG9ubHkgQ29ubmVjdG9yW10sXG4gIGFjY291bnRTdGF0dXM6IHN0cmluZyxcbikge1xuICBjb25zdCBbYXZhaWxhYmlsaXR5LCBzZXRBdmFpbGFiaWxpdHldID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNoZWNrQ29ubmVjdG9yQXZhaWxhYmlsaXR5KCkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBjb25uZWN0b3JzLm1hcChhc3luYyAoY29ubmVjdG9yKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6ZWQgPSBhd2FpdCBjb25uZWN0b3IuaXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGNvbm5lY3Rvci51aWQsIGF1dGhvcml6ZWQgfTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogY29ubmVjdG9yLnVpZCwgYXV0aG9yaXplZDogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIG5leHRbcmVzdWx0LmtleV0gPSByZXN1bHQuYXV0aG9yaXplZDtcbiAgICAgIH1cbiAgICAgIHNldEF2YWlsYWJpbGl0eShuZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB2b2lkIGNoZWNrQ29ubmVjdG9yQXZhaWxhYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEF2YWlsYWJpbGl0eSh7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW2Nvbm5lY3RvcnMsIGFjY291bnRTdGF0dXNdKTtcblxuICByZXR1cm4gYXZhaWxhYmlsaXR5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFsYW5jZURhdGEocGFyYW1zOiB7XG4gIGFjY2VwdHM6IFg0MDJQYXltZW50UmVxdWlyZW1lbnRbXTtcbiAgY2hhaW5Db25maWc/OiBDaGFpbkNvbmZpZztcbiAgY2hhaW5Db25maWdzPzogUmVjb3JkPHN0cmluZywgQ2hhaW5Db25maWc+O1xuICBhZGRyZXNzPzogQWRkcmVzcztcbiAgc2hvd0JhbGFuY2VzOiBib29sZWFuO1xufSkge1xuICBjb25zdCB7IGFjY2VwdHMsIGNoYWluQ29uZmlnLCBjaGFpbkNvbmZpZ3MsIGFkZHJlc3MsIHNob3dCYWxhbmNlcyB9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IGJhbGFuY2VDb25maWdzID0gdXNlTWVtbzxCYWxhbmNlQ29uZmlnRW50cnlbXT4oXG4gICAgKCkgPT4gYnVpbGRCYWxhbmNlQ29uZmlncyhhY2NlcHRzLCBjaGFpbkNvbmZpZywgY2hhaW5Db25maWdzKSxcbiAgICBbYWNjZXB0cywgY2hhaW5Db25maWcsIGNoYWluQ29uZmlnc10sXG4gICk7XG5cbiAgY29uc3QgYmFsYW5jZUNvbnRyYWN0cyA9IHVzZU1lbW88QmFsYW5jZUNvbnRyYWN0c0NhbGxbXT4oKCkgPT4ge1xuICAgIGlmICghYWRkcmVzcykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGNhbGxzOiBCYWxhbmNlQ29udHJhY3RzQ2FsbFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGJhbGFuY2VDb25maWdzKSB7XG4gICAgICBpZiAoIWVudHJ5LmNvbmZpZyB8fCBlbnRyeS5lcnJvciB8fCAhZW50cnkudXNkY0FkZHJlc3MpIGNvbnRpbnVlO1xuICAgICAgY2FsbHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IGVudHJ5LnVzZGNBZGRyZXNzLFxuICAgICAgICBhYmk6IFVTRENfQUJJLFxuICAgICAgICBmdW5jdGlvbk5hbWU6ICdiYWxhbmNlT2YnLFxuICAgICAgICBhcmdzOiBbYWRkcmVzc10sXG4gICAgICAgIGNoYWluSWQ6IGVudHJ5LmNvbmZpZy5jaGFpbklkLFxuICAgICAgfSk7XG4gICAgICBjYWxscy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogZW50cnkudXNkY0FkZHJlc3MsXG4gICAgICAgIGFiaTogVVNEQ19BQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogJ2RlY2ltYWxzJyxcbiAgICAgICAgY2hhaW5JZDogZW50cnkuY29uZmlnLmNoYWluSWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbHM7XG4gIH0sIFthZGRyZXNzLCBiYWxhbmNlQ29uZmlnc10pO1xuXG4gIGNvbnN0IGJhbGFuY2VRdWVyeUVuYWJsZWQgPVxuICAgIHNob3dCYWxhbmNlcyAmJiBCb29sZWFuKGFkZHJlc3MpICYmIGJhbGFuY2VDb250cmFjdHMubGVuZ3RoID4gMDtcblxuICBjb25zdCBiYWxhbmNlUXVlcnkgPSB1c2VSZWFkQ29udHJhY3RzKHtcbiAgICBjb250cmFjdHM6IGJhbGFuY2VDb250cmFjdHMsXG4gICAgYWxsb3dGYWlsdXJlOiB0cnVlLFxuICAgIHF1ZXJ5OiB7XG4gICAgICBlbmFibGVkOiBiYWxhbmNlUXVlcnlFbmFibGVkLFxuICAgICAgcmV0cnk6IDIsXG4gICAgICBzdGFsZVRpbWU6IDMwXzAwMCxcbiAgICB9LFxuICB9KTtcblxuICBjb25zdCBiYWxhbmNlcyA9IHVzZU1lbW88QmFsYW5jZUluZm9bXT4oKCkgPT4ge1xuICAgIGlmICghc2hvd0JhbGFuY2VzIHx8ICFhZGRyZXNzIHx8IGJhbGFuY2VDb25maWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgaWYgKCFiYWxhbmNlUXVlcnkuZGF0YSkge1xuICAgICAgcmV0dXJuIGJhbGFuY2VDb25maWdzXG4gICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiAhZW50cnkuY29uZmlnIHx8IGVudHJ5LmVycm9yKVxuICAgICAgICAubWFwKChlbnRyeSkgPT4gYnVpbGRCYWxhbmNlRXJyb3IoZW50cnksIGVudHJ5LmVycm9yID8/ICdNaXNzaW5nIGNoYWluIGNvbmZpZ3VyYXRpb24nKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0czogQmFsYW5jZUluZm9bXSA9IFtdO1xuICAgIGxldCBkYXRhSW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBiYWxhbmNlQ29uZmlncykge1xuICAgICAgaWYgKCFlbnRyeS5jb25maWcgfHwgZW50cnkuZXJyb3IgfHwgIWVudHJ5LnVzZGNBZGRyZXNzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChidWlsZEJhbGFuY2VFcnJvcihlbnRyeSwgZW50cnkuZXJyb3IgPz8gJ01pc3NpbmcgY2hhaW4gY29uZmlndXJhdGlvbicpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhbGFuY2VSZXN1bHQgPSBiYWxhbmNlUXVlcnkuZGF0YVtkYXRhSW5kZXhdO1xuICAgICAgY29uc3QgZGVjaW1hbHNSZXN1bHQgPSBiYWxhbmNlUXVlcnkuZGF0YVtkYXRhSW5kZXggKyAxXTtcbiAgICAgIGRhdGFJbmRleCArPSAyO1xuXG4gICAgICBpZiAoIWJhbGFuY2VSZXN1bHQgfHwgIWRlY2ltYWxzUmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChidWlsZEJhbGFuY2VFcnJvcihlbnRyeSwgJ0JhbGFuY2UgdW5hdmFpbGFibGUnKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGJhbGFuY2VSZXN1bHQuc3RhdHVzID09PSAnZmFpbHVyZScgfHxcbiAgICAgICAgZGVjaW1hbHNSZXN1bHQuc3RhdHVzID09PSAnZmFpbHVyZSdcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnIgPVxuICAgICAgICAgIGJhbGFuY2VSZXN1bHQuc3RhdHVzID09PSAnZmFpbHVyZSdcbiAgICAgICAgICAgID8gYmFsYW5jZVJlc3VsdC5lcnJvclxuICAgICAgICAgICAgOiBkZWNpbWFsc1Jlc3VsdC5lcnJvcjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGZldGNoIGJhbGFuY2UnO1xuICAgICAgICByZXN1bHRzLnB1c2goYnVpbGRCYWxhbmNlRXJyb3IoZW50cnksIG1lc3NhZ2UpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY2ltYWxzUmF3ID0gZGVjaW1hbHNSZXN1bHQucmVzdWx0O1xuICAgICAgY29uc3QgYmFsYW5jZVJhdyA9IGJhbGFuY2VSZXN1bHQucmVzdWx0O1xuICAgICAgaWYgKFxuICAgICAgICAodHlwZW9mIGRlY2ltYWxzUmF3ICE9PSAnYmlnaW50JyAmJiB0eXBlb2YgZGVjaW1hbHNSYXcgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAodHlwZW9mIGJhbGFuY2VSYXcgIT09ICdiaWdpbnQnICYmIHR5cGVvZiBiYWxhbmNlUmF3ICE9PSAnbnVtYmVyJylcbiAgICAgICkge1xuICAgICAgICByZXN1bHRzLnB1c2goYnVpbGRCYWxhbmNlRXJyb3IoZW50cnksICdCYWxhbmNlIHVuYXZhaWxhYmxlJykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVjaW1hbHNWYWx1ZSA9XG4gICAgICAgIHR5cGVvZiBkZWNpbWFsc1JhdyA9PT0gJ2JpZ2ludCcgPyBOdW1iZXIoZGVjaW1hbHNSYXcpIDogZGVjaW1hbHNSYXc7XG4gICAgICBjb25zdCBiYWxhbmNlVmFsdWUgPVxuICAgICAgICB0eXBlb2YgYmFsYW5jZVJhdyA9PT0gJ2JpZ2ludCcgPyBiYWxhbmNlUmF3IDogQmlnSW50KGJhbGFuY2VSYXcpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkID0gTnVtYmVyKGZvcm1hdFVuaXRzKGJhbGFuY2VWYWx1ZSwgZGVjaW1hbHNWYWx1ZSkpO1xuXG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBuZXR3b3JrOiBlbnRyeS5hY2NlcHQubmV0d29yayxcbiAgICAgICAgY2hhaW5OYW1lOiBlbnRyeS5jb25maWcubmFtZSxcbiAgICAgICAgYmFsYW5jZTogZm9ybWF0dGVkLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9LCBbYWRkcmVzcywgYmFsYW5jZUNvbmZpZ3MsIGJhbGFuY2VRdWVyeS5kYXRhLCBzaG93QmFsYW5jZXNdKTtcblxuICByZXR1cm4ge1xuICAgIGJhbGFuY2VzLFxuICAgIGlzTG9hZGluZzogYmFsYW5jZVF1ZXJ5LmlzRmV0Y2hpbmcsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBheXdhbGxSZWR1Y2VyKHN0YXRlOiBQYXl3YWxsU3RhdGUsIGFjdGlvbjogUGF5d2FsbEFjdGlvbik6IFBheXdhbGxTdGF0ZSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdzZXRTdGF0dXMnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHN0YXR1czogYWN0aW9uLnN0YXR1cyB9O1xuICAgIGNhc2UgJ3NldFByb2Nlc3NpbmdUZXh0JzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBwcm9jZXNzaW5nVGV4dDogYWN0aW9uLnRleHQgfTtcbiAgICBjYXNlICdzZXRFcnJvcic6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc3RhdHVzOiAnZXJyb3InLCBlcnJvck1lc3NhZ2U6IGFjdGlvbi5tZXNzYWdlIH07XG4gICAgY2FzZSAncmVzZXQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBhY3Rpb24uc3RhdHVzLFxuICAgICAgICBlcnJvck1lc3NhZ2U6ICcnLFxuICAgICAgICBwcm9jZXNzaW5nVGV4dDogYWN0aW9uLnByb2Nlc3NpbmdUZXh0LFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXl3YWxsU3RhdHVzKHBhcmFtcz86IHtcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIGRlZmF1bHRQcm9jZXNzaW5nVGV4dD86IHN0cmluZztcbn0pIHtcbiAgY29uc3QgZGVmYXVsdFByb2Nlc3NpbmdUZXh0ID0gcGFyYW1zPy5kZWZhdWx0UHJvY2Vzc2luZ1RleHQgPz8gREVGQVVMVF9QUk9DRVNTSU5HX1RFWFQ7XG4gIGNvbnN0IG9uRXJyb3IgPSBwYXJhbXM/Lm9uRXJyb3I7XG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihwYXl3YWxsUmVkdWNlciwge1xuICAgIHN0YXR1czogJ2Nvbm5lY3QnLFxuICAgIGVycm9yTWVzc2FnZTogJycsXG4gICAgcHJvY2Vzc2luZ1RleHQ6IGRlZmF1bHRQcm9jZXNzaW5nVGV4dCxcbiAgfSk7XG5cbiAgY29uc3Qgc2V0U3RhdHVzID0gdXNlQ2FsbGJhY2soKHN0YXR1czogUGF5d2FsbFN0YXR1cykgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ3NldFN0YXR1cycsIHN0YXR1cyB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldFByb2Nlc3NpbmdUZXh0ID0gdXNlQ2FsbGJhY2soKHRleHQ6IHN0cmluZykgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ3NldFByb2Nlc3NpbmdUZXh0JywgdGV4dCB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNob3dFcnJvciA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXNzYWdlOiBzdHJpbmcsIGVycj86IHVua25vd24pID0+IHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG1lc3NhZ2UgfHwgJ1BheW1lbnQgZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdzZXRFcnJvcicsIG1lc3NhZ2U6IGVycm9yVGV4dCB9KTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yPy4oZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSkge1xuICAgICAgICBvbkVycm9yPy4obmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtvbkVycm9yXSxcbiAgKTtcblxuICBjb25zdCByZXNldFN0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHN0YXR1czogUGF5d2FsbFN0YXR1cyA9ICdjb25uZWN0JykgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAncmVzZXQnLCBzdGF0dXMsIHByb2Nlc3NpbmdUZXh0OiBkZWZhdWx0UHJvY2Vzc2luZ1RleHQgfSk7XG4gICAgfSxcbiAgICBbZGVmYXVsdFByb2Nlc3NpbmdUZXh0XSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXR1czogc3RhdGUuc3RhdHVzLFxuICAgIGVycm9yTWVzc2FnZTogc3RhdGUuZXJyb3JNZXNzYWdlLFxuICAgIHByb2Nlc3NpbmdUZXh0OiBzdGF0ZS5wcm9jZXNzaW5nVGV4dCxcbiAgICBzZXRTdGF0dXMsXG4gICAgc2V0UHJvY2Vzc2luZ1RleHQsXG4gICAgc2hvd0Vycm9yLFxuICAgIHJlc2V0U3RhdGUsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25Mb2NrKCkge1xuICBjb25zdCBhY3Rpb25Mb2NrUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgYWN0aW9uTm9uY2VSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IFtpc0FjdGlvbkJ1c3ksIHNldElzQWN0aW9uQnVzeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgYmVnaW5BY3Rpb24gPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyIHwgbnVsbCA9PiB7XG4gICAgaWYgKGFjdGlvbkxvY2tSZWYuY3VycmVudCkgcmV0dXJuIG51bGw7XG4gICAgYWN0aW9uTG9ja1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRJc0FjdGlvbkJ1c3kodHJ1ZSk7XG4gICAgYWN0aW9uTm9uY2VSZWYuY3VycmVudCArPSAxO1xuICAgIHJldHVybiBhY3Rpb25Ob25jZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZW5kQWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGFjdGlvbkxvY2tSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIHNldElzQWN0aW9uQnVzeShmYWxzZSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBpc0FjdGlvblN0YWxlID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGlvbklkOiBudW1iZXIpID0+IGFjdGlvbk5vbmNlUmVmLmN1cnJlbnQgIT09IGFjdGlvbklkLFxuICAgIFtdLFxuICApO1xuXG4gIGNvbnN0IHJlc2V0QWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGFjdGlvbk5vbmNlUmVmLmN1cnJlbnQgKz0gMTtcbiAgICBhY3Rpb25Mb2NrUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBzZXRJc0FjdGlvbkJ1c3koZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbkFjdGlvbixcbiAgICBlbmRBY3Rpb24sXG4gICAgaXNBY3Rpb25TdGFsZSxcbiAgICByZXNldEFjdGlvbixcbiAgICBpc0FjdGlvbkJ1c3ksXG4gIH07XG59XG5cbnR5cGUgVXNlUGF5bWVudFN1Ym1pc3Npb25QYXJhbXMgPSB7XG4gIGFjY291bnRBZGRyZXNzPzogQWRkcmVzcztcbiAgYWNjb3VudENoYWluSWQ/OiBudW1iZXI7XG4gIHJlcXVpcmVtZW50PzogWDQwMlBheW1lbnRSZXF1aXJlbWVudDtcbiAgcmVzb2x2ZWRDaGFpbj86IENoYWluQ29uZmlnO1xuICBhbW91bnRBdG9taWM/OiBzdHJpbmcgfCBudWxsO1xuICBwYXltZW50UmVxdWlyZWQ6IFg0MDJQYXltZW50UmVxdWlyZWQ7XG4gIGN1cnJlbnRVcmw6IHN0cmluZztcbiAgcmVxdWVzdEluaXQ/OiBSZXF1ZXN0SW5pdDtcbiAgb25TdWNjZXNzPzogKFxuICAgIHJlc3VsdDogdW5rbm93bixcbiAgICBjb250ZXh0OiB7XG4gICAgICByZXNwb25zZTogUmVzcG9uc2U7XG4gICAgICBwYXltZW50SGVhZGVyOiBzdHJpbmc7XG4gICAgfSxcbiAgKSA9PiB2b2lkO1xuICBiZWdpbkFjdGlvbjogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgZW5kQWN0aW9uOiAoKSA9PiB2b2lkO1xuICBpc0FjdGlvblN0YWxlOiAoYWN0aW9uSWQ6IG51bWJlcikgPT4gYm9vbGVhbjtcbiAgc2V0U3RhdHVzOiAoc3RhdHVzOiBQYXl3YWxsU3RhdHVzKSA9PiB2b2lkO1xuICBzZXRQcm9jZXNzaW5nVGV4dDogKHRleHQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc2hvd0Vycm9yOiAobWVzc2FnZTogc3RyaW5nLCBlcnI/OiB1bmtub3duKSA9PiB2b2lkO1xufTtcblxudHlwZSBVc2VDb25uZWN0b3JDb25uZWN0UGFyYW1zID0ge1xuICBhY2NvdW50U3RhdHVzPzogc3RyaW5nO1xuICByZXNvbHZlZENoYWluPzogQ2hhaW5Db25maWc7XG4gIG9uQ29ubmVjdGVkOiAoKSA9PiB2b2lkO1xuICBiZWdpbkFjdGlvbjogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgZW5kQWN0aW9uOiAoKSA9PiB2b2lkO1xuICBpc0FjdGlvblN0YWxlOiAoYWN0aW9uSWQ6IG51bWJlcikgPT4gYm9vbGVhbjtcbiAgc2V0U3RhdHVzOiAoc3RhdHVzOiBQYXl3YWxsU3RhdHVzKSA9PiB2b2lkO1xuICBzZXRQcm9jZXNzaW5nVGV4dDogKHRleHQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc2hvd0Vycm9yOiAobWVzc2FnZTogc3RyaW5nLCBlcnI/OiB1bmtub3duKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbm5lY3RvckNvbm5lY3QocGFyYW1zOiBVc2VDb25uZWN0b3JDb25uZWN0UGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBhY2NvdW50U3RhdHVzLFxuICAgIHJlc29sdmVkQ2hhaW4sXG4gICAgb25Db25uZWN0ZWQsXG4gICAgYmVnaW5BY3Rpb24sXG4gICAgZW5kQWN0aW9uLFxuICAgIGlzQWN0aW9uU3RhbGUsXG4gICAgc2V0U3RhdHVzLFxuICAgIHNldFByb2Nlc3NpbmdUZXh0LFxuICAgIHNob3dFcnJvcixcbiAgfSA9IHBhcmFtcztcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNvbm5lY3QoKTtcblxuICBjb25zdCBpc0FscmVhZHlDb25uZWN0ZWQgPSB1c2VDYWxsYmFjaygoZXJyb3I6IHVua25vd24pID0+IHtcbiAgICBpZiAoIWVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdG9yQWxyZWFkeUNvbm5lY3RlZEVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBlcnIgPSBlcnJvciBhcyB7IG5hbWU/OiBzdHJpbmc7IG1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgICBpZiAoZXJyLm5hbWUgPT09ICdDb25uZWN0b3JBbHJlYWR5Q29ubmVjdGVkRXJyb3InKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gQm9vbGVhbihlcnIubWVzc2FnZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYWxyZWFkeSBjb25uZWN0ZWQnKSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjb25uZWN0V2l0aENvbm5lY3RvciA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjb25uZWN0b3I6IENvbm5lY3RvcikgPT4ge1xuICAgICAgaWYgKCFyZXNvbHZlZENoYWluKSB7XG4gICAgICAgIHNob3dFcnJvcignTWlzc2luZyBjaGFpbiBjb25maWd1cmF0aW9uIGZvciB0aGlzIHBheW1lbnQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhY2NvdW50U3RhdHVzID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBvbkNvbm5lY3RlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb25JZCA9IGJlZ2luQWN0aW9uKCk7XG4gICAgICBpZiAoIWFjdGlvbklkKSByZXR1cm47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldFN0YXR1cygncHJvY2Vzc2luZycpO1xuICAgICAgICBzZXRQcm9jZXNzaW5nVGV4dChgQ29ubmVjdGluZyAke2Nvbm5lY3Rvci5uYW1lfS4uLmApO1xuXG4gICAgICAgIGF3YWl0IGNvbm5lY3QubXV0YXRlQXN5bmMoe1xuICAgICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgICBjaGFpbklkOiByZXNvbHZlZENoYWluLmNoYWluSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNBY3Rpb25TdGFsZShhY3Rpb25JZCkpIHJldHVybjtcblxuICAgICAgICBvbkNvbm5lY3RlZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlDb25uZWN0ZWQoZXJyKSkge1xuICAgICAgICAgIG9uQ29ubmVjdGVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVc2VyUmVqZWN0aW9uKGVycikpIHtcbiAgICAgICAgICBzaG93RXJyb3IoJ0Nvbm5lY3Rpb24gcmVqZWN0ZWQgYnkgdXNlcicsIGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvd0Vycm9yKChlcnIgYXMgRXJyb3IpLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBjb25uZWN0IHdhbGxldCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVuZEFjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgYWNjb3VudFN0YXR1cyxcbiAgICAgIGJlZ2luQWN0aW9uLFxuICAgICAgY29ubmVjdCxcbiAgICAgIGVuZEFjdGlvbixcbiAgICAgIGlzQWxyZWFkeUNvbm5lY3RlZCxcbiAgICAgIGlzQWN0aW9uU3RhbGUsXG4gICAgICBvbkNvbm5lY3RlZCxcbiAgICAgIHJlc29sdmVkQ2hhaW4sXG4gICAgICBzZXRQcm9jZXNzaW5nVGV4dCxcbiAgICAgIHNldFN0YXR1cyxcbiAgICAgIHNob3dFcnJvcixcbiAgICBdLFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgY29ubmVjdFdpdGhDb25uZWN0b3IsXG4gICAgaXNQZW5kaW5nOiBjb25uZWN0LmlzUGVuZGluZyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBheW1lbnRTdWJtaXNzaW9uKHBhcmFtczogVXNlUGF5bWVudFN1Ym1pc3Npb25QYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGFjY291bnRBZGRyZXNzLFxuICAgIGFjY291bnRDaGFpbklkLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIHJlc29sdmVkQ2hhaW4sXG4gICAgYW1vdW50QXRvbWljLFxuICAgIHBheW1lbnRSZXF1aXJlZCxcbiAgICBjdXJyZW50VXJsLFxuICAgIHJlcXVlc3RJbml0LFxuICAgIG9uU3VjY2VzcyxcbiAgICBiZWdpbkFjdGlvbixcbiAgICBlbmRBY3Rpb24sXG4gICAgaXNBY3Rpb25TdGFsZSxcbiAgICBzZXRTdGF0dXMsXG4gICAgc2V0UHJvY2Vzc2luZ1RleHQsXG4gICAgc2hvd0Vycm9yLFxuICB9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IHNpZ25UeXBlZERhdGEgPSB1c2VTaWduVHlwZWREYXRhKCk7XG4gIGNvbnN0IHN3aXRjaENoYWluID0gdXNlU3dpdGNoQ2hhaW4oKTtcblxuICBjb25zdCBlbnN1cmVDaGFpbiA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjb25maWc6IENoYWluQ29uZmlnKSA9PiB7XG4gICAgICBpZiAoYWNjb3VudENoYWluSWQgPT09IGNvbmZpZy5jaGFpbklkKSByZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzd2l0Y2hDaGFpbi5tdXRhdGVBc3luYyh7IGNoYWluSWQ6IGNvbmZpZy5jaGFpbklkIH0pO1xuICAgICAgfSBjYXRjaCAoc3dpdGNoRXJyb3I6IHVua25vd24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIChzd2l0Y2hFcnJvciBhcyBFcnJvcikubWVzc2FnZSB8fFxuICAgICAgICAgICAgYFBsZWFzZSBzd2l0Y2ggdG8gJHtjb25maWcubmFtZX0gaW4geW91ciB3YWxsZXQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFthY2NvdW50Q2hhaW5JZCwgc3dpdGNoQ2hhaW5dLFxuICApO1xuXG4gIGNvbnN0IHNpZ25QYXltZW50ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYWNjb3VudEFkZHJlc3MpIHtcbiAgICAgIHNob3dFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1aXJlbWVudCB8fCAhcmVzb2x2ZWRDaGFpbikge1xuICAgICAgc2hvd0Vycm9yKCdNaXNzaW5nIHBheW1lbnQgcmVxdWlyZW1lbnQgb3IgY2hhaW4gY29uZmlndXJhdGlvbi4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVpcmVtZW50LnBheVRvIHx8ICFhbW91bnRBdG9taWMgfHwgIXJlcXVpcmVtZW50LmFzc2V0KSB7XG4gICAgICBzaG93RXJyb3IoJ1BheW1lbnQgcmVxdWlyZW1lbnQgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXh0cmEgPSByZXF1aXJlbWVudC5leHRyYSBhcyB7IG5hbWU/OiB1bmtub3duOyB2ZXJzaW9uPzogdW5rbm93biB9IHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRvbWFpbk5hbWUgPSB0eXBlb2YgZXh0cmE/Lm5hbWUgPT09ICdzdHJpbmcnID8gZXh0cmEubmFtZSA6IG51bGw7XG4gICAgY29uc3QgZG9tYWluVmVyc2lvbiA9IHR5cGVvZiBleHRyYT8udmVyc2lvbiA9PT0gJ3N0cmluZycgPyBleHRyYS52ZXJzaW9uIDogbnVsbDtcblxuICAgIGlmICghZG9tYWluTmFtZSB8fCAhZG9tYWluVmVyc2lvbikge1xuICAgICAgc2hvd0Vycm9yKCdQYXltZW50IHJlcXVpcmVtZW50IG1pc3NpbmcgRUlQLTcxMiBkb21haW4gZGV0YWlscy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb25JZCA9IGJlZ2luQWN0aW9uKCk7XG4gICAgaWYgKCFhY3Rpb25JZCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXR1cygncHJvY2Vzc2luZycpO1xuICAgICAgc2V0UHJvY2Vzc2luZ1RleHQoJ0NoZWNraW5nIG5ldHdvcmsuLi4nKTtcbiAgICAgIGF3YWl0IGVuc3VyZUNoYWluKHJlc29sdmVkQ2hhaW4pO1xuICAgICAgaWYgKGlzQWN0aW9uU3RhbGUoYWN0aW9uSWQpKSByZXR1cm47XG4gICAgICBzZXRQcm9jZXNzaW5nVGV4dCgnUHJlcGFyaW5nIHBheW1lbnQuLi4nKTtcblxuICAgICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3MoYWNjb3VudEFkZHJlc3MpO1xuICAgICAgY29uc3QgdG8gPSBnZXRBZGRyZXNzKHJlcXVpcmVtZW50LnBheVRvKTtcbiAgICAgIGNvbnN0IGFzc2V0ID0gZ2V0QWRkcmVzcyhyZXF1aXJlbWVudC5hc3NldCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbm9ybWFsaXplQXRvbWljQW1vdW50KGFtb3VudEF0b21pYykgPz8gYW1vdW50QXRvbWljO1xuICAgICAgY29uc3QgdmFsdWUgPSBCaWdJbnQobm9ybWFsaXplZEFtb3VudCk7XG4gICAgICBjb25zdCBtYXhUaW1lb3V0U2Vjb25kcyA9IHJlcXVpcmVtZW50Lm1heFRpbWVvdXRTZWNvbmRzID8/IERFRkFVTFRfVElNRU9VVF9TRUNPTkRTO1xuICAgICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCB2YWxpZEFmdGVyID0gQmlnSW50KG5vdyAtIENMT0NLX1NLRVdfU0VDT05EUyk7XG4gICAgICBjb25zdCB2YWxpZEJlZm9yZSA9IEJpZ0ludChub3cgKyBtYXhUaW1lb3V0U2Vjb25kcyk7XG4gICAgICBjb25zdCBub25jZSA9IHRvSGV4KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSk7XG5cbiAgICAgIGNvbnN0IGRvbWFpbiA9IHtcbiAgICAgICAgbmFtZTogZG9tYWluTmFtZSxcbiAgICAgICAgdmVyc2lvbjogZG9tYWluVmVyc2lvbixcbiAgICAgICAgY2hhaW5JZDogcmVzb2x2ZWRDaGFpbi5jaGFpbklkLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogYXNzZXQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbGlkQWZ0ZXIsXG4gICAgICAgIHZhbGlkQmVmb3JlLFxuICAgICAgICBub25jZSxcbiAgICAgIH07XG5cbiAgICAgIHNldFByb2Nlc3NpbmdUZXh0KCdQbGVhc2Ugc2lnbiBpbiB5b3VyIHdhbGxldC4uLicpO1xuXG4gICAgICBjb25zdCB0eXBlZERhdGEgPSBidWlsZFRyYW5zZmVyQXV0aG9yaXphdGlvblR5cGVkRGF0YSh7IGRvbWFpbiwgbWVzc2FnZSB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSk7XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25UeXBlZERhdGEubXV0YXRlQXN5bmModHlwZWREYXRhKTtcbiAgICAgIGlmIChpc0FjdGlvblN0YWxlKGFjdGlvbklkKSkgcmV0dXJuO1xuXG4gICAgICBzZXRQcm9jZXNzaW5nVGV4dCgnU3VibWl0dGluZyBwYXltZW50Li4uJyk7XG5cbiAgICAgIGNvbnN0IHBheW1lbnRQYXlsb2FkID0ge1xuICAgICAgICB4NDAyVmVyc2lvbjogcGF5bWVudFJlcXVpcmVkLng0MDJWZXJzaW9uLFxuICAgICAgICBzY2hlbWU6IHJlcXVpcmVtZW50LnNjaGVtZSxcbiAgICAgICAgbmV0d29yazogcmVxdWlyZW1lbnQubmV0d29yayxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiB7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHZhbGlkQWZ0ZXI6IHZhbGlkQWZ0ZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHZhbGlkQmVmb3JlOiB2YWxpZEJlZm9yZS50b1N0cmluZygpLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBheW1lbnRIZWFkZXIgPSBlbmNvZGVCYXNlNjRKc29uKHBheW1lbnRQYXlsb2FkKTtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RJbml0Py5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMuc2V0KCdYLVBBWU1FTlQtU0lHTkFUVVJFJywgcGF5bWVudEhlYWRlcik7XG4gICAgICBoZWFkZXJzLnNldCgnUEFZTUVOVC1TSUdOQVRVUkUnLCBwYXltZW50SGVhZGVyKTtcbiAgICAgIGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGN1cnJlbnRVcmwsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0SW5pdD8ubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICAuLi5yZXF1ZXN0SW5pdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzQWN0aW9uU3RhbGUoYWN0aW9uSWQpKSByZXR1cm47XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAoZXJyb3JEYXRhIGFzIHsgbWVzc2FnZT86IHN0cmluZyB9KS5tZXNzYWdlIHx8XG4gICAgICAgICAgJ1BheW1lbnQgdmVyaWZpY2F0aW9uIGZhaWxlZCc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdDogdW5rbm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBY3Rpb25TdGFsZShhY3Rpb25JZCkpIHJldHVybjtcblxuICAgICAgc2V0U3RhdHVzKCdzdWNjZXNzJyk7XG4gICAgICBvblN1Y2Nlc3M/LihyZXN1bHQsIHsgcmVzcG9uc2UsIHBheW1lbnRIZWFkZXIgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBpZiAoaXNVc2VyUmVqZWN0aW9uKGVycikpIHtcbiAgICAgICAgc2hvd0Vycm9yKCdUcmFuc2FjdGlvbiByZWplY3RlZCBieSB1c2VyJywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3dFcnJvcigoZXJyIGFzIEVycm9yKS5tZXNzYWdlIHx8ICdQYXltZW50IGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nLCBlcnIpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRBY3Rpb24oKTtcbiAgICB9XG4gIH0sIFtcbiAgICBhY2NvdW50QWRkcmVzcyxcbiAgICBhbW91bnRBdG9taWMsXG4gICAgYmVnaW5BY3Rpb24sXG4gICAgZW5kQWN0aW9uLFxuICAgIGVuc3VyZUNoYWluLFxuICAgIGlzQWN0aW9uU3RhbGUsXG4gICAgb25TdWNjZXNzLFxuICAgIHBheW1lbnRSZXF1aXJlZC54NDAyVmVyc2lvbixcbiAgICByZXF1ZXN0SW5pdCxcbiAgICByZXF1aXJlbWVudCxcbiAgICByZXNvbHZlZENoYWluLFxuICAgIHNldFByb2Nlc3NpbmdUZXh0LFxuICAgIHNldFN0YXR1cyxcbiAgICBzaG93RXJyb3IsXG4gICAgc2lnblR5cGVkRGF0YSxcbiAgICBjdXJyZW50VXJsLFxuICBdKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25QYXltZW50LFxuICAgIGlzUGVuZGluZzogc2lnblR5cGVkRGF0YS5pc1BlbmRpbmcgfHwgc3dpdGNoQ2hhaW4uaXNQZW5kaW5nLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImZvcm1hdFVuaXRzIiwiZ2V0QWRkcmVzcyIsInRvSGV4IiwidmFsaWRhdGVUeXBlZERhdGEiLCJDb25uZWN0b3JBbHJlYWR5Q29ubmVjdGVkRXJyb3IiLCJ1c2VDb25uZWN0IiwidXNlUmVhZENvbnRyYWN0cyIsInVzZVNpZ25UeXBlZERhdGEiLCJ1c2VTd2l0Y2hDaGFpbiIsImJ1aWxkQmFsYW5jZUNvbmZpZ3MiLCJidWlsZEJhbGFuY2VFcnJvciIsImJ1aWxkVHJhbnNmZXJBdXRob3JpemF0aW9uVHlwZWREYXRhIiwiQ0xPQ0tfU0tFV19TRUNPTkRTIiwiREVGQVVMVF9QUk9DRVNTSU5HX1RFWFQiLCJERUZBVUxUX1RJTUVPVVRfU0VDT05EUyIsImlzVXNlclJlamVjdGlvbiIsIm5vcm1hbGl6ZUF0b21pY0Ftb3VudCIsIlVTRENfQUJJIiwiZW5jb2RlQmFzZTY0SnNvbiIsInVzZUNvbm5lY3RvckF2YWlsYWJpbGl0eSIsImNvbm5lY3RvcnMiLCJhY2NvdW50U3RhdHVzIiwiYXZhaWxhYmlsaXR5Iiwic2V0QXZhaWxhYmlsaXR5IiwiY2FuY2VsbGVkIiwiY2hlY2tDb25uZWN0b3JBdmFpbGFiaWxpdHkiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNvbm5lY3RvciIsImF1dGhvcml6ZWQiLCJpc0F1dGhvcml6ZWQiLCJrZXkiLCJ1aWQiLCJuZXh0IiwicmVzdWx0IiwibGVuZ3RoIiwidXNlQmFsYW5jZURhdGEiLCJwYXJhbXMiLCJhY2NlcHRzIiwiY2hhaW5Db25maWciLCJjaGFpbkNvbmZpZ3MiLCJhZGRyZXNzIiwic2hvd0JhbGFuY2VzIiwiYmFsYW5jZUNvbmZpZ3MiLCJiYWxhbmNlQ29udHJhY3RzIiwiY2FsbHMiLCJlbnRyeSIsImNvbmZpZyIsImVycm9yIiwidXNkY0FkZHJlc3MiLCJwdXNoIiwiYWJpIiwiZnVuY3Rpb25OYW1lIiwiYXJncyIsImNoYWluSWQiLCJiYWxhbmNlUXVlcnlFbmFibGVkIiwiQm9vbGVhbiIsImJhbGFuY2VRdWVyeSIsImNvbnRyYWN0cyIsImFsbG93RmFpbHVyZSIsInF1ZXJ5IiwiZW5hYmxlZCIsInJldHJ5Iiwic3RhbGVUaW1lIiwiYmFsYW5jZXMiLCJkYXRhIiwiZmlsdGVyIiwiZGF0YUluZGV4IiwiYmFsYW5jZVJlc3VsdCIsImRlY2ltYWxzUmVzdWx0Iiwic3RhdHVzIiwiZXJyIiwibWVzc2FnZSIsIkVycm9yIiwiZGVjaW1hbHNSYXciLCJiYWxhbmNlUmF3IiwiZGVjaW1hbHNWYWx1ZSIsIk51bWJlciIsImJhbGFuY2VWYWx1ZSIsIkJpZ0ludCIsImZvcm1hdHRlZCIsIm5ldHdvcmsiLCJhY2NlcHQiLCJjaGFpbk5hbWUiLCJuYW1lIiwiYmFsYW5jZSIsImlzTG9hZGluZyIsImlzRmV0Y2hpbmciLCJwYXl3YWxsUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsInByb2Nlc3NpbmdUZXh0IiwidGV4dCIsImVycm9yTWVzc2FnZSIsInVzZVBheXdhbGxTdGF0dXMiLCJkZWZhdWx0UHJvY2Vzc2luZ1RleHQiLCJvbkVycm9yIiwiZGlzcGF0Y2giLCJzZXRTdGF0dXMiLCJzZXRQcm9jZXNzaW5nVGV4dCIsInNob3dFcnJvciIsImVycm9yVGV4dCIsInJlc2V0U3RhdGUiLCJ1c2VBY3Rpb25Mb2NrIiwiYWN0aW9uTG9ja1JlZiIsImFjdGlvbk5vbmNlUmVmIiwiaXNBY3Rpb25CdXN5Iiwic2V0SXNBY3Rpb25CdXN5IiwiYmVnaW5BY3Rpb24iLCJjdXJyZW50IiwiZW5kQWN0aW9uIiwiaXNBY3Rpb25TdGFsZSIsImFjdGlvbklkIiwicmVzZXRBY3Rpb24iLCJ1c2VDb25uZWN0b3JDb25uZWN0IiwicmVzb2x2ZWRDaGFpbiIsIm9uQ29ubmVjdGVkIiwiY29ubmVjdCIsImlzQWxyZWFkeUNvbm5lY3RlZCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJjb25uZWN0V2l0aENvbm5lY3RvciIsIm11dGF0ZUFzeW5jIiwiaXNQZW5kaW5nIiwidXNlUGF5bWVudFN1Ym1pc3Npb24iLCJhY2NvdW50QWRkcmVzcyIsImFjY291bnRDaGFpbklkIiwicmVxdWlyZW1lbnQiLCJhbW91bnRBdG9taWMiLCJwYXltZW50UmVxdWlyZWQiLCJjdXJyZW50VXJsIiwicmVxdWVzdEluaXQiLCJvblN1Y2Nlc3MiLCJzaWduVHlwZWREYXRhIiwic3dpdGNoQ2hhaW4iLCJlbnN1cmVDaGFpbiIsInN3aXRjaEVycm9yIiwic2lnblBheW1lbnQiLCJwYXlUbyIsImFzc2V0IiwiZXh0cmEiLCJkb21haW5OYW1lIiwiZG9tYWluVmVyc2lvbiIsInZlcnNpb24iLCJmcm9tIiwidG8iLCJub3JtYWxpemVkQW1vdW50IiwidmFsdWUiLCJtYXhUaW1lb3V0U2Vjb25kcyIsIm5vdyIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJ2YWxpZEFmdGVyIiwidmFsaWRCZWZvcmUiLCJub25jZSIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJkb21haW4iLCJ2ZXJpZnlpbmdDb250cmFjdCIsInR5cGVkRGF0YSIsInNpZ25hdHVyZSIsInBheW1lbnRQYXlsb2FkIiwieDQwMlZlcnNpb24iLCJzY2hlbWUiLCJwYXlsb2FkIiwiYXV0aG9yaXphdGlvbiIsInRvU3RyaW5nIiwicGF5bWVudEhlYWRlciIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2V0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../src/paywall-hooks.ts\n"));

/***/ })

});